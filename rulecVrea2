// ... (existing code)

const MyComponent = () => {
    // ... (existing code)

    // Define the handler for adding a nested group condition or condition
    const addNestedConditionOrGroup = (index, isGroup) => {
        // Make a copy of the state array
        let newConditions = [...conditions];

        // Determine the type of the new condition based on the isGroup parameter
        const newConditionType = isGroup ? 'groupCondition' : 'condition';

        // Add a new condition object to the conditions array of the group condition object at the given index
        newConditions[index].conditions.push({
            type: newConditionType,
            ...(isGroup && { conditions: [] }), // If it's a group, initialize the conditions array
            selectOperation: 'select',
            selectCondition: 'select',
            requestAttribute: 'select',
            requestOp: 'select',
            requestValue: '',
            groupAttribute: 'select',
            groupOp: 'select',
            groupValue: '',
            identityAttribute: 'select',
            identityOp: 'select',
            identityValue: '',
            locationAttribute: 'select',
            locationOp: 'select',
            locationValue: '',
        });

        // Set the new state array
        setConditions(newConditions);
    };

    // ... (existing code)

    return (
        <div>
            {/* ... (existing code) */}
            {conditions.map((condition, index) => (
                condition.type === "condition" ? 
                <div key={index}>
                    {/* ... (existing code) */}
                </div> :
// Handle group condition rendering here
<div key={index}>
    {/* Render select operation if it's not the first condition/group */}
    {index > 0 && (
        <div>
            Select Operation : 
            <select 
                value={condition.selectOperation} 
                onChange={(e) => handleChange(index, 'selectOperation', e.target.value)}
            >
                {selectOperationOptions.map(option => 
                    <option key={option} value={option}>{option}</option>
                )}
            </select>
        </div>
    )}
    {/* Button to add a new condition */}
    <button onClick={() => addNestedConditionOrGroup(index, false)}>
        Add Condition
    </button>
    {/* Button to add a new group condition */}
    <button onClick={() => addNestedConditionOrGroup(index, true)}>
        Add Group Condition
    </button>
    {/* Render nested conditions recursively */}
    {condition.conditions.map((nestedCondition, nestedIndex) => (
        <div key={nestedIndex}>
            {/* ... (similar structure for nested conditions) */}
            {/* Check if the nested condition is a groupCondition */}
            {nestedCondition.type === 'groupCondition' && (
                <div>
                    {/* Button to add a new nested group condition */}
                    <button onClick={() => addNestedConditionOrGroup(index, true)}>
                        Add Nested Group Condition
                    </button>
                    {/* Render nested conditions recursively */}
                    {nestedCondition.conditions.map((nestedNestedCondition, nestedNestedIndex) => (
                        <div key={nestedNestedIndex}>
                            {/* ... (similar structure for nested nested conditions) */}
                        </div>
                    ))}
                </div>
            )}
        </div>
    ))}
    {/* ... (existing code) */}
                </div>
            ))}
            {/* ... (existing code) */}
        </div>
    );
};
