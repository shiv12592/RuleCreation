import React, { useState } from 'react';
import { Container, Row, Col, Button, Select } from 'react-bootstrap';

const MyComponent = () => {
  const [allData, setAllData] = useState([]);

  // Define data
  const conditionData = {
    selectCondition: ['select', 'Request', 'Group'],
    requestAttribute: ['select', 'rqAtt1', 'reqAtt2'],
    groupAttribute: ['select', 'grpAtt1', 'grpAtt2'],
    requestOp: ['select', 'equal', 'noEqual'],
    groupOp: ['select', 'and', 'or', not],
    selectOperation : ['select','AND','OR']
  };

  // Map all data and render rows
  const renderRows = () => {
    // Initialize an empty array to store the rows
    let rows = [];

    // Loop through the allData state and create a row for each condition or group
    for (let i = 0; i < allData.length; i++) {
      let data = allData[i];

      // Check if the data is a condition or a group
      if (data.type === 'condition') {
        // Create a row with four fields for source, attribute, operation, and value
        let row = (
          <Row key={i} className="margin-1-tb line-border">
            <Col md={3}>
              <label className="margin-1-lr">Source</label>
              <Select
                value={data.selectCondition}
                onChange={(e) => handleSelectConditionChange(e, i)}
                options={conditionData.selectCondition}
              />
            </Col>
            <Col md={3}>
              <label className="margin-1-lr">Attribute</label>
              <Select
                value={data.attribute}
                onChange={(e) => handleAttributeChange(e, i)}
                options={
                  data.selectCondition === 'Request'
                    ? conditionData.requestAttribute
                    : conditionData.groupAttribute
                }
              />
            </Col>
            <Col md={3}>
              <label className="margin-1-lr">Operation</label>
              <Select
                value={data.operation}
                onChange={(e) => handleOperationChange(e, i)}
                options={
                  data.selectCondition === 'Request'
                    ? conditionData.requestOp
                    : conditionData.groupOp
                }
              />
            </Col>
            <Col md={3}>
              <label className="margin-1-lr">Value</label>
              <input
                type="text"
                value={data.value}
                onChange={(e) => handleValueChange(e, i)}
                placeholder={
                  data.selectCondition === 'Request'
                    ? 'req value'
                    : 'group value'
                }
              />
            </Col>
            <Button
              className="style danger, font-color-red, background - light-gray, margin 1 -tb"
              onClick={() => handleRemoveRow(i)}
            >
              Remove Row
            </Button>
          </Row>
        );

        // Push the row to the rows array
        rows.push(row);
      } else if (data.type === 'group') {
        // Create a row with two buttons for adding condition or group
        let row = (
          <Row key={i} className="margin-1-tb line-border">
            <label>Add Condition</label>
            <Button onClick={() => handleAddCondition(i)}>Add Condition</Button>
            <label>Add Group of Condition</label>
            <Button
              className="background - light-gray"
              onClick={() => handleAddGroup(i)}
            >
              Add Group Condition
            </Button>
            <Button onClick={() => handleRemoveGroup(i)}>Remove Group</Button>
          </Row>
        );

        // Push the row to the rows array
        rows.push(row);

        // Recursively render the nested rows for the group
        let nestedRows = renderRows(data.rows);

        // Push the nested rows to the rows array
        rows.push(...nestedRows);
      }

      // Check if there is a next row and add a select operation row
      if (i < allData.length - 1) {
        let row = (
          <Row key={`${i}-op`} className="dash-border">
            <label>Select Operation</label>
            <Select
              value={data.selectOperation}
              onChange={(e) => handleSelectOperationChange(e, i)}
              options={conditionData.selectOperation}
            />
          </Row>
        );

        // Push the row to the rows array
        rows.push(row);
      }
    }

    // Return the rows array
    return rows;
  };

  // Handle the change of selectCondition field
  const handleSelectConditionChange = (e, i) => {
    // Get the new value
    let value = e.target.value;

    // Update the allData state by copying the previous state and modifying the selectCondition field of the i-th element
    setAllData((prev) =>
      prev.map((data, index) =>
        index === i ? { ...data, selectCondition: value } : data
      )
    );
  };

  // Handle the change of attribute field
  const handleAttributeChange = (e, i) => {
    // Get the new value
    let value = e.target.value;

    // Update the allData state by copying the previous state and modifying the attribute field of the i-th element
    setAllData((prev) =>
      prev.map((data, index) => (index === i ? { ...data, attribute: value } : data))
    );
  };

  // Handle the change of operation field
  const handleOperationChange = (e, i) => {
    // Get the new value
    let value = e.target.value;

    // Update the allData state by copying the previous state and modifying the operation field of the i-th element
    setAllData((prev) =>
      prev.map((data, index) => (index === i ? { ...data, operation: value } : data))
    );
  };

  // Handle the change of value field
  const handleValueChange = (e, i) => {
    // Get the new value
    let value = e.target.value;

    // Update the allData state by copying the previous state and modifying the value field of the i-th element
    setAllData((prev) =>
      prev.map((data, index) => (index === i ? { ...data, value: value } : data))
    );
  };

  // Handle the change of selectOperation field
  const handleSelectOperationChange = (e, i) => {
    // Get the new value
    let value = e.target.value;

    // Update the allData state by copying the previous state and modifying the selectOperation field of the i-th element
    setAllData((prev) =>
      prev.map((data, index) =>
        index === i ? { ...data, selectOperation: value } : data
      )
    );
  };

  // Handle the click of add condition button
  const handleAddCondition = (i) => {
    // Create a new condition object with default values
    let newCondition = {
      type: 'condition',
      selectCondition: 'select',
      attribute: 'select',
      operation: 'select',
      value: '',
      selectOperation: 'select'
    };

    // Update the allData state by copying the previous state and inserting the new condition object after the i-th element
    setAllData((prev) => [
      ...prev.slice(0, i + 1),
      newCondition,
      ...prev.slice(i + 1)
    ]);
  };

  // Handle the click of add group button
  const handleAddGroup = (i) => {
    // Create a new group object with an empty rows array
    let newGroup = {
      type: 'group',
      rows: []
    };

    // Update the allData state by copying the previous state and inserting the new group object after the i-th element
    setAllData((prev) => [...prev.slice(0, i + 1), newGroup, ...prev.slice(i + 1)]);
  };

  // Handle the click of remove row button
  const handleRemoveRow = (i) => {
    // Update the allData state by copying the previous state and removing the i-th element
    setAllData((prev) => prev.filter((data, index) => index !== i));
  };

  // Handle the click of remove group button
  const handleRemoveGroup = (i) => {
    // Update the allData state by copying the previous state and removing the i-th element and its nested rows
    setAllData((prev) => {
      // Find the next group or the end of the array
      let nextGroupIndex = prev.findIndex(
        (data, index) => index > i && data.type === 'group'
      );
      if (nextGroupIndex === -1) {
        nextGroupIndex = prev.length;
      }

      // Return the filtered array
      return [
        ...prev.slice(0, i),
        ...prev.slice(nextGroupIndex)
      ];
    });
  };

  return (
    <div className="col-md-12">
      <Container className="col-md-12">
        <Row className="line-border">
          <label>Add Condition</label>
          <Button onClick={() => handleAddCondition(-1)}>Add Condition</Button>
          <label>Add Group of Condition</label>
          <Button
            className="background - light-gray"
            onClick={() => handleAddGroup(-1)}
          >
            Add 
Group Condition
</Button>
</Row>
{renderRows()}
<Button onClick={() => console.log(JSON.stringify(allData))}>Submit</Button>
</Container>
</div>
);
};

export default MyComponent;
