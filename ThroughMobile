// Define a recursive component that renders a condition or a group condition
const Condition = ({ condition, index, nestedIndex, handleChange, handleNestedChange, addGroupCondition, addNestedCondition, removeCondition, removeGroupCondition, removeNestedCondition }) => {
  // Define the options for the select fields
  const selectConditionOptions = ['select', 'Request', 'group', 'identity', 'location'];
  const requestAttributeOptions = ['select', 'rqAtt1', 'reqAtt2'];
  const groupAttributeOptions = ['select', 'grpAtt1', 'grpAtt2'];
  const identityAttributeOptions = ['select', 'idAtt1', 'idAtt2'];
  const locationAttributeOptions = ['select', 'locAtt1', 'locAtt2'];
  const requestOpOptions = ['select', 'equal', 'noEqual'];
  const groupOpOptions = ['select', 'and', 'or', 'not'];
  const identityOpOptions = ['select', 'is', 'isNot'];
  const locationOpOptions = ['select', 'in', 'notIn'];
  const selectOperationOptions = ['select', 'AND', 'OR'];

  // Check the type of the condition object
  if (condition.type === 'condition') {
    // Render a normal condition
    return (
      <div>
        {index > 0 && <div>Select Operation : <select value={condition.selectOperation} onChange={(e) => handleChange(index, 'selectOperation', e.target.value)}>
          {selectOperationOptions.map(option => <option key={option} value={option}>{option}</option>)}
        </select></div>}
        Source : <select value={condition.selectCondition} onChange={(e) => handleChange(index, 'selectCondition', e.target.value)}>
          {selectConditionOptions.map(option => <option key={option} value={option}>{option}</option>)}
        </select>
        {condition.selectCondition === 'Request' && <>
          Request Attribute : <select value={condition.requestAttribute} onChange={(e) => handleChange(index, 'requestAttribute', e.target.value)}>
            {requestAttributeOptions.map(option => <option key={option} value={option}>{option}</option>)}
          </select>
          Request Operation : <select value={condition.requestOp} onChange={(e) => handleChange(index, 'requestOp', e.target.value)}>
            {requestOpOptions.map(option => <option key={option} value={option}>{option}</option>)}
          </select>
          Request Value : <input type="text" value={condition.requestValue} onChange={(e) => handleChange(index, 'requestValue', e.target.value)} />
        </>}
        {condition.selectCondition === 'group' && <>
          Group Attribute : <select value={condition.groupAttribute} onChange={(e) => handleChange(index, 'groupAttribute', e.target.value)}>
            {groupAttributeOptions.map(option => <option key={option} value={option}>{option}</option>)}
          </select>
          Group Operation : <select value={condition.groupOp} onChange={(e) => handleChange(index, 'groupOp', e.target.value)}>
            {groupOpOptions.map(option => <option key={option} value={option}>{option}</option>)}
          </select>
          Group Value : <input type="text" value={condition.groupValue} onChange={(e) => handleChange(index, 'groupValue', e.target.value)} />
        </>}
        {condition.selectCondition === 'identity' && <>
          Identity Attribute : <select value={condition.identityAttribute} onChange={(e) => handleChange(index, 'identityAttribute', e.target.value)}>
            {identityAttributeOptions.map(option => <option key={option} value={option}>{option}</option>)}
          </select>
          Identity Operation : <select value={condition.identityOp} onChange={(e) => handleChange(index, 'identityOp', e.target.value)}>
            {identityOpOptions.map(option => <option key={option} value={option}>{option}</option>)}
          </select>
          Identity Value : <input type="text" value={condition.identityValue} onChange={(e) => handleChange(index, 'identityValue', e.target.value)} />
        </>}
        {condition.selectCondition === 'location' && <>
          Location Attribute : <select value={condition.locationAttribute} onChange={(e) => handleChange(index, 'locationAttribute', e.target.value)}>
            {locationAttributeOptions.map(option => <option key={option} value={option}>{option}</option>)}
          </select>
          Location Operation : <select value={condition.locationOp} onChange={(e) => handleChange(index, 'locationOp', e.target.value)}>
            {locationOpOptions.map(option => <option key={option} value={option}>{option}</option>)}
          </select>
          Location Value : <input type="text" value={condition.locationValue} onChange={(e) => handleChange(index, 'locationValue', e.target.value)} />
        </>}
        <button onClick={() => removeCondition(index)}>Remove Condition</button>
      </div>
    );
  } else if (condition.type === 'groupCondition') {
    // Render a group condition
    return (
      <fieldset>
        {index > 0 && <div>Select Operation : <select value={condition.selectOperation} onChange={(e) => handleChange(index, 'selectOperation', e.target.value)}>
          {selectOperationOptions.map(option => <option key={option} value={option}>{option}</option>)}
        </select></div>}
        {nestedIndex === undefined && <button onClick={() => addGroupCondition(index)}>Add Group Condition</button>}
        {condition.conditions.map((nestedCondition, nestedIndex) => (
          // Render each nested condition using the same component
          <Condition
            key={nestedIndex}
            condition={nestedCondition}
            index={index}
            nestedIndex={nestedIndex}
            handleChange={handleChange}
            handleNestedChange={handleNestedChange}
            addGroupCondition={addGroupCondition}
            addNestedCondition={addNestedCondition}
            removeCondition={removeCondition}
            removeGroupCondition={removeGroupCondition}
            removeNestedCondition={removeNestedCondition}
          />
        ))}
        <button onClick={() => removeGroupCondition(index)}>Remove Group</button>
      </fieldset>
    );
  }
};



