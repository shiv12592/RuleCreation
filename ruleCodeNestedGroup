import React, { useState } from 'react';

const MyComponent = () => {
    // Define the initial state for the conditions
    const [conditions, setConditions] = useState([]);

    // Define the handler for adding a condition
    const addCondition = () => {
        // Add a new condition object to the state array
        setConditions([...conditions, { type: 'condition', selectCondition: 'select', requestAttribute: 'select', requestOp: 'select', requestValue: '', groupAttribute: 'select', groupOp: 'select', groupValue: '', identityAttribute: 'select', identityOp: 'select', identityValue: '', locationAttribute: 'select', locationOp: 'select', locationValue: '' }]);
    };

    // Define the handler for adding a group condition
    const addGroupCondition = () => {
        // Add a new group condition object to the state array
        setConditions([...conditions, { type: 'groupCondition', conditions: [{ selectCondition: 'select', requestAttribute: 'select', requestOp: 'select', requestValue: '', groupAttribute: 'select', groupOp: 'select', groupValue: '', identityAttribute: 'select', identityOp: 'select', identityValue: '', locationAttribute: 'select', locationOp: 'select', locationValue: '' }], selectOperation : "select" }]);
    };

    // Define the handler for submitting the form
    const handleSubmit = () => {
        // Make a copy of the state array
        let newConditions = [...conditions];
        // Loop through the conditions and remove the unnecessary fields
        newConditions.forEach(condition => {
            if (condition.type === 'condition') {
                // Get the selected condition value
                let selectedCondition = condition.selectCondition;
                // Loop through the selectConditionFields object
                for (let [key, value] of Object.entries(selectConditionFields)) {
                    // If the key is not equal to the selected condition value, delete the fields from the condition object
                    if (key !== selectedCondition) {
                        value.forEach(field => delete condition[field]);
                    }
                }
            } else if (condition.type === 'groupCondition') {
                condition.conditions.forEach(nestedCondition => {
                    if (nestedCondition.type === 'condition') {
                        // Get the selected condition value
                        let selectedCondition = nestedCondition.selectCondition;
                        // Loop through the selectConditionFields object
                        for (let [key, value] of Object.entries(selectConditionFields)) {
                            // If the key is not equal to the selected condition value, delete the fields from the nested condition object
                            if (key !== selectedCondition) {
                                value.forEach(field => delete nestedCondition[field]);
                            }
                        }
                    } else if (nestedCondition.type === 'groupCondition') {
                        nestedCondition.conditions.forEach(nestedNestedCondition => {
                            // Get the selected condition value
                            let selectedCondition = nestedNestedCondition.selectCondition;
                            // Loop through the selectConditionFields object
                            for (let [key, value] of Object.entries(selectConditionFields)) {
                                // If the key is not equal to the selected condition value, delete the fields from the nested nested condition object
                                if (key !== selectedCondition) {
                                    value.forEach(field => delete nestedNestedCondition[field]);
                                }
                            }
                        });
                    }
                });
            }
        });
        // Log the new state array as JSON to the console
        console.log(JSON.stringify(newConditions));
    };

    // Define the handler for changing the value of a field in a condition
    const handleChange = (index, field, value) => {
        // Make a copy of the state array
        let newConditions = [...conditions];
        // Update the value of the field in the condition object at the given index
        newConditions[index][field] = value;
        // If the field is selectCondition, reset the other fields to their initial values
        if (field === 'selectCondition') {
            newConditions[index].requestAttribute = 'select';
            newConditions[index].requestOp = 'select';
            newConditions[index].requestValue = '';
            newConditions[index].groupAttribute = 'select';
            newConditions[index].groupOp = 'select';
            newConditions[index].groupValue = '';
            newConditions[index].identityAttribute = 'select';
            newConditions[index].identityOp = 'select';
            newConditions[index].identityValue = '';
            newConditions[index].locationAttribute = 'select';
            newConditions[index].locationOp = 'select';
            newConditions[index].locationValue = '';
        }
        // Set the new state array
        setConditions(newConditions);
    };

    // Define the handler for changing the value of a field in a nested condition
    const handleNestedChange = (index, nestedIndex, field, value) => {
        // Make a copy of the state array
        let newConditions = [...conditions];
        // Update the value of the field in the nested condition object at the given indexes
        newConditions[index].conditions[nestedIndex][field] = value;
        // If the field is selectCondition, reset the other fields to their initial values
        if (field === 'selectCondition') {
            newConditions[index].conditions[nestedIndex].requestAttribute = 'select';
            newConditions[index].conditions[nestedIndex].requestOp = 'select';
            newConditions[index].conditions[nestedIndex].requestValue = '';
            newConditions[index].conditions[nestedIndex].groupAttribute = 'select';
            newConditions[index].conditions[nestedIndex].groupOp = 'select';
            newConditions[index].conditions[nestedIndex].groupValue = '';
            newConditions[index].conditions[nestedIndex].identityAttribute = 'select';
            newConditions[index].conditions[nestedIndex].identityOp = 'select';
            newConditions[index].conditions[nestedIndex].identityValue = '';
            newConditions[index].conditions[nestedIndex].locationAttribute = 'select';
            newConditions[index].conditions[nestedIndex].locationOp = 'select';
            newConditions[index].conditions[nestedIndex].locationValue = '';
        }
        // Set the new state array
        setConditions(newConditions);
    };

    // Define the handler for changing the value of a field in a nested nested condition
    const handleNestedNestedChange = (index, nestedIndex, nestedNestedIndex, field, value) => {
        // Make a copy of the state array
        let newConditions = [...conditions];
        // Update the value of the field in the nested nested condition object at the given indexes
        newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex][field] = value;
        // If the field is selectCondition, reset the other fields to their initial values
        if (field === 'selectCondition') {
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].requestAttribute = 'select';
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].requestOp = 'select';
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].requestValue = '';
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].groupAttribute = 'select';
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].groupOp = 'select';
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].groupValue = '';
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].identityAttribute = 'select';
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].identityOp = 'select';
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].identityValue = '';
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].locationAttribute = 'select';
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].locationOp = 'select';
            newConditions[index].conditions[nestedIndex].conditions[nestedNestedIndex].locationValue = '';
        }
        // Set the new state array
        setConditions(newConditions);
    };

    // Define the handler for adding a nested condition
    const addNestedCondition = (index) => {
        // Make a copy of the state array
        let newConditions = [...conditions];
        // Add a new nested condition object to the conditions array of the group condition object at the given index
        newConditions[index].conditions.push({ type: 'condition', selectCondition: 'select', requestAttribute: 'select', requestOp: 'select', requestValue: '', groupAttribute: 'select', groupOp: 'select', groupValue: '', identityAttribute: 'select', identityOp: 'select', identityValue: '', locationAttribute: 'select', locationOp: 'select', locationValue: '' });
        // Set the new state array
        setConditions(newConditions);
    };

    // Define the handler for adding a nested group condition
    const addNestedGroupCondition = (index) => {
        // Make a copy of the state array
        let newConditions = [...conditions];
        // Add a new nested group condition object to the conditions array of the group condition object at the given index
        newConditions[index].conditions.push({ type: 'groupCondition', conditions: [{ selectCondition: 'select', requestAttribute: 'select', requestOp: 'select', requestValue: '', groupAttribute: 'select', groupOp: 'select', groupValue: '', identityAttribute: 'select', identityOp: 'select', identityValue: '', locationAttribute: 'select', locationOp: 'select', locationValue: '' }], selectOperation : "select" });
        // Set the new state array
        setConditions(newConditions);
    };

    //Define the handler for removing a nested nested condition
const removeNestedNestedCondition = (index, nestedIndex, nestedNestedIndex) => {
// Make a copy of the state array
let newConditions = [...conditions];
// Remove the nested nested condition object at the given indexes
newConditions[index].conditions[nestedIndex].conditions.splice(nestedNestedIndex, 1);
// Set the new state array
setConditions(newConditions);
};
  // Define the handler for removing a group condition
const removeGroupCondition = (index) => {
    // Make a copy of the state array
    let newConditions = [...conditions];
    // Remove the group condition object at the given index
    newConditions.splice(index, 1);
    // Set the new state array
    setConditions(newConditions);
};

// Define the handler for removing a nested condition
const removeNestedCondition = (index, nestedIndex) => {
    // Make a copy of the state array
    let newConditions = [...conditions];
    // Remove the nested condition object at the given indexes
    newConditions[index].conditions.splice(nestedIndex, 1);
    // Set the new state array
    setConditions(newConditions);
};

// Define the handler for submitting the form
const handleSubmit = () => {
    // Make a copy of the state array
    let newConditions = [...conditions];
    // Loop through the conditions and remove the unnecessary fields
    newConditions.forEach(condition => {
        if (condition.type === 'condition') {
            // Get the selected condition value
            let selectedCondition = condition.selectCondition;
            // Loop through the selectConditionFields object
            for (let [key, value] of Object.entries(selectConditionFields)) {
                // If the key is not equal to the selected condition value, delete the fields from the condition object
                if (key !== selectedCondition) {
                    value.forEach(field => delete condition[field]);
                }
            }
        } else if (condition.type === 'groupCondition') {
            condition.conditions.forEach(nestedCondition => {
                if (nestedCondition.type === 'condition') {
                    // Get the selected condition value
                    let selectedCondition = nestedCondition.selectCondition;
                    // Loop through the selectConditionFields object
                    for (let [key, value] of Object.entries(selectConditionFields)) {
                        // If the key is not equal to the selected condition value, delete the fields from the nested condition object
                        if (key !== selectedCondition) {
                            value.forEach(field => delete nestedCondition[field]);
                        }
                    }
                } else if (nestedCondition.type === 'groupCondition') {
                    nestedCondition.conditions.forEach(nestedNestedCondition => {
                        // Get the selected condition value
                        let selectedCondition = nestedNestedCondition.selectCondition;
                        // Loop through the selectConditionFields object
                        for (let [key, value] of Object.entries(selectConditionFields)) {
                            // If the key is not equal to the selected condition value, delete the fields from the nested nested condition object
                            if (key !== selectedCondition) {
                                value.forEach(field => delete nestedNestedCondition[field]);
                            }
                        }
                    });
                }
            });
        }
    });
    // Log the new state array as JSON to the console
    console.log(JSON.stringify(newConditions));
};

// ... (Rest of the existing code)

return (
    <div>
        {/* ... (Existing JSX) */}

        {conditions.map((condition, index) => (
            // ... (Existing JSX)

            <div key={index}>
                {/* ... (Existing JSX) */}

                {condition.conditions.map((nestedCondition, nestedIndex) => (
                    // ... (Existing JSX)

                    <div key={nestedIndex}>
                        {/* ... (Existing JSX) */}

                        {nestedCondition.conditions.map((nestedNestedCondition, nestedNestedIndex) => (
                            <div key={nestedNestedIndex}>
                                {/* ... (Existing JSX) */}

                                <button onClick={() => removeNestedNestedCondition(index, nestedIndex, nestedNestedIndex)}>
                                    Remove Nested Nested Condition
                                </button>
                            </div>
                        ))}
                        <button onClick={() => addNestedCondition(index)}>Add Nested Condition</button>
                        <button onClick={() => addNestedGroupCondition(index)}>Add Nested Group Condition</button>
                        <button onClick={() => removeNestedCondition(index, nestedIndex)}>Remove Nested Condition</button>
                    </div>
                ))}

                <button onClick={() => addNestedCondition(index)}>Add Nested Condition</button>
                <button onClick={() => addNestedGroupCondition(index)}>Add Nested Group Condition</button>
                <button onClick={() => removeGroupCondition(index)}>Remove Group Condition</button>
            </div>
        ))}
        <button onClick={handleSubmit}>Submit</button>
    </div>
);


  
